


(include "kit/macros")
(import-namespace kit)

(include "kit/header")

(require! 'sibilant 'repl 'chokidar

          (lit Interface) "./lib/index"
          (lit File-system) "./lib/file-system"
          (lit Source-map) "./lib/source-map"
          (lit Process) "./lib/electron"
          (lit Client) "./lib/repl")

(print "source map" Source-map)

(macro entask (o ...body) `(set @o 'state (then  (get @o 'state) state ...@body)))


(def invalidate-module-cache  ([src lib])
  (delete (get require.cache src.path))
  (delete (get require.cache lib.path)))

(def refresh-module ([src lib])
  (invalidate-module-cache [src lib])
  (require lib.path))

(pipe Source-map.event
      (.on  'update (aprint "updated") )
      (.on 'update invalidate-module-cache)
      (.on  'load (aprint "loaded") ))

;; next step is to revise the engine, move all relevent code in sib to src and
;; build it to compile properly to lib
(.load Compiler ["index" "file-system" "source-map" "interface" "tree" "electron"])



;; ;; Process is the electron context, the browser space, where all our code is to be evaluated
;; (const process (.spawn Process "game"))
;; ;; The client sets up a connection with a server spawned by the process.
;; ;; we will send from the client to the server javascript that is to be executed in the context.
;; (const client (.spawn Client ))

;; (.once process 'load
;;        (-> (.start client)))


;; ;; (pipe (.then (-> )
;; ;;              (athrow Error "failed to load"))

;; ;;       (.then (-> ) (athrow Error "failed to load")))

