(var  fields [])

(var state-space (create State-space))

(def-interface Component (x y (neiborhood (moore x y this.field)))

  (gett influences (pipe this.system.influences (.map  (=> (s) (.get s.field this.x this.y)))))

  (gett value (.get this.field this.x this.y))
  (sett value v (.set this.field this.x this.y v)))

(def-interface Field-system
    (name
     (render? false) height width

     (symbol (Symbol name))
     (field (state-space width height))
     (components [])
     ;; collection of systems whos values influence this one

     (layer (if render? (.get sim.layers) (new Set)))

     (system this)
     (*Component (extend  this Component )))

  (extend Matrix )

  (gett Component this.*Component)
  (doc "A quantity which has a value over every point of a global space for all locations in space and time.")
  (height sim.*width)

  (width sim.*width)
  (gett array this.components)

  (init (.push systems this))

  (def-generic  populate (field )
    "for every value influenced by the field, create a point object to represent that value"

    (pipe field (each (v x y) (.add-component this x y v))))

  (def-generic clear (field components)
    (.transit field (=> (x) 0))
    (.update field)
    (.transit field (=> (x) x))
    (.update field))

  (def-generic add-component ( x y value *Component layer components)

    (var component ((create *Component) x y ))

    (.push components component)
    (.add layer component))

  (def-generic remove-component (r layer components)

    (.filter components (=> (c) (not (= r c))))

    (.delete layer r))

  (def-generic update (ticks components field )
    "update every component of the field."
    (pipe components (each (c) (.update c ticks)))))


(def-generic randomize-field (field (system this))

  (.transit field (=> (x) (Math.random)))
  (.update field)
  (.transit field (=> (x) x))
  (.update field)
  (assign system.max 0))

(assign Field-system.randomize randomize-field)

(var field-system (create Field-system))
