
(include "../object-pool.sibilant")

(def singleton ()
  "A builder function for instantiating interfaces
who are to only have one instance, them selves."
  (.init this))
;; Last, but not least, this is where we finally make use of the object pool.
;; The Pooled system is a template instance, which we will use to build our entity system,
;; and all future systems.


(def-interface Pooled-system
    (limit interface (*pool ((create Object-pool) limit interface)))

  (limit 10000)

  (init (.register this interface))

  (systems (new Map))

  (def-generic clear (*pool)
    (each *pool.*in-use (e) (.despawn e))
    (.clear *pool))

  (def spawn ((dots args))
    "aquire an object from the systems pool, and initialize it."
    (collect r (pipe this.*pool (.aquire))
             (.init r (dots args))
             ))

  (def despawn (obj)
    "remove an object from the system, and release it back into the pool."

    ;;(print "despawn?" obj)
    (.clear obj)
    (pipe this.*pool
          (.release obj)))

  (def register (interface)
    "Associate an interface with a system, and add the system
to the collection of all active systems."
    (assign interface.system this)

    (.set this.systems this this))

  (def update ()

    "update every active member of the system"

    (each this.*pool.*in-use (member)
          (.update member))))

;; I want to remove the position, color, and collision aspects of an entity from the
;; entity its self.
;; Having any data at all in the entity defeats the purpose of the entity entirely.


;; But this will work for now.

(var entity-layer (.get sim.layers))

(def-interface Entity  (x y aspects)


  (gett aspects   (console.trace "aspect gotten" this.aspect) this.aspect)
  (sett aspects a (console.trace "setting aspect from" this.aspect "to" a) (assign this.aspect a))

  (init

   (assign this.event (new Event-emitter))
   (if (not (.has Collision [x y]))
       (do (.set Collision [x y] this)


           (.add  this.layer this)
         (assign this.*spawned true)

         (assign this.components
                 (.map aspects (=> (T) (set this T.symbol (create-instance-of T this)))))

         ;;;(print "initializing entity" this)
         )

       (do (assign this.*spawned true)
           ;;(print "there was a collision" this)
           (.despawn this))))

  (layer entity-layer)

  (def spawn ()
    "Aquire an empty entity instance, and initialize it."


    (.spawn this.system (dots arguments)))

  (gmth clear ((entity this) layer)
        "remove an entity from the system, and clear its component list."


        ;;(print "clearing" entity)
        (.delete Collision [entity.x entity.y])
        (.delete layer entity)
        (.remove-all-listeners entity.event "error")

        (assign entity.event null
                entity.*spawned false)


        (assign entity.components [])
        ;;(print "cleared" entity)
        entity)

  (def despawn ()

    "Remove this entity from the system."

    (when this.*spawned
      (.despawn this.system this))
    this)


  (gmth update (components)
        "update every component of this entity in order of appearance."
        (each components (comp) (.update comp this))))

(def-interface Entity-system (limit)

  (extend Pooled-system)

  (init (.call Pooled-system.init this limit this.interface))

  (interface Entity)


  (mth move (entity [x y])
       "move an entity to the given location, if the location does not collide with any other entities."
       (.move Collision [x y] entity)))

(include "./entities/algae.sibilant")

;; (def-interface Component-type ())
;; (def-interface Component-system (limit)
;;   (extend Pooled-system)
;;   (interface Component-type))
