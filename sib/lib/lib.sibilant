(meta
 (namespace kit)

 (macro transpile-name (name)
        `(get (sibilant (get (first (get @name "contents")) 'token)) 'js))

 (macro describe (name ...body)
        `(mixin (lit ...@body) @name))

 (macro def-lit-macro (name args ...body)

        (assign name (transpile-name `(@ name)))

        (var t (pipe  `(lambda @args ...@body)
                      transpile
                      output-formatter)
             )
        (print "def-lit-maco fail!" t)
        (set lit-macros name (eval t))

        null

        )

 (macro lit (...body) `(literal ...@(.map body global.lit-macros )))

 (def global.lit-macros (el)

   (print el)


   (if (expression? el)

       (do (var name (transpile-name el))

           (print "it was an expression" name lit-macros)
         (if (and (literal? (first el.contents))
                  (has-key? lit-macros name))

             ((get lit-macros name) (dots (rest (content-of el))))

             `(property ...@(content-of el))))
       el))

 (def lit-macros.init (args ...body)
   `(init @args ...@body))

 (def lit-macros.gett (name ...body)
   `(gett @name ...@body))

 (def lit-macros.alias (name from)
   `(alias @name @from))

 (def lit-macros.sett (name value-name ...body)
   `(sett @name @value-name ...@body))
 (def lit-macros.gmth (name args ...body)
   `(gmth @name @args ...@body))
 )


(include "./natives/array.sibilant"
         "./natives/map.sibilant"
         ;;"./natives/set.sibilant"
         )

(include "./obj/interface")

(include "./common/promise-writer" )

(include "./math")
(include "./html/element"
         "./html/dom")



(require! (lit Matrix  Matrix-view Kernel ) "kit/sib/matrix"
          (lit Tree-map) "kit/sib/data-structures"
          )

(include "./state-space.sibilant")

(var set-value (R.curry (=> (value entity) (assign entity.value value))))
(var curry R.curry)
(var (lit ( not fnot) (pipe fpipe) equals) R)

;;(include "./field.sibilant")

(def Object.prototype.each (f)
  (each (Object.keys this) (k)
        (f (get this k) k)))
(set global
     'create create
     'extend extend
     'mixin mixin)

(var green (color 0 255 0) yellow (color 255  255  0))

(def memoize (f)

  "create a memoized version of any function. A memoized function will return
previously calculated results from a cache if the arguments given to it are the same"

  (var m {})

  (cond R.has R.prop (=> ((dots args)) (f.apply this args))))
