(console.log "gl" window.gl)

(include "kit/macros.sibilant")
(include "kit/header")

(macro def-system (name args ...body)
       `(def-interface @name ()

          (init (.call Pooled-system.init this))
          (extend Pooled-system)

          ...@(.map (content-of args) (=> (name) `(@name [])))
          ...@body))

(def-curried fset (o k v) (set o k v))

(require! 'sibilant)


(import-namespace kit)

(def window.size () [window.inner-width window.inner-height])

(include "./headers"
         "./inc/math"
         "./inc/vertex"
         "./shaders"
         "./object-pool.sibilant"
         "./ticker"
         "./game"
         "./pooled-system.sibilant"
         "./entity-system.sibilant"
         ;; "./systems/vertex-context.sibilant"
         ;; "./systems/interfaces/field"
         ;; "./systems/random-field"

         ;;"./tests.sibilant"
         "./systems/rendering"

         )

;; it is just very hard to build a game which can have individual parts of it reprogrammed!
;; (def-interface Game ()

;;   (services [])
;;   (systems [])
;;   (ticker (pipe Ticker (.init  10) .start
;;                 (.remove-all-listeners 'tick)
;;                 (.on 'tick (=> (now tick) (.update systems)))))

;;   (def-generic update (systems))
;;   (def start ()
;;     (.init this)))

;; (def-interface System ()
;;   (extend Pooled-system))

;; (def-interface Systems ()
;;   (extend Pooled-system)
;;   (interface System))

;; (def-interface Services ())


(var dim (window.size))

;; (var context ((create Vertex-context) dim))

;; (def-interface Data-layer ())
;; (def-interface View-layer ())

;; (def-interface Layers (data view)

;;   (extend Pooled-system)

;;   (def add-data ())
;;   (def add-view ()))

;; (var rand-field ((create Random-field) (.map dim (fpipe (/ 4) Math.ceil)) context 4))

;; (print rand-field)

;; (.populate rand-field)

(var lagged-ticks 0)

(def handle-lag ( (default handle-lag (-> )))

  (if (> Ticker.elapsed Ticker.rate)
      (handle-lag)
      (assign lagged-ticks 0)))

;; (print (.get rand-field.matrix 10 10))

;; (def-interface Tile-system (layers )
;;   (extend Pooled-system))

;; (var test-unit (.spawn context))
;; (var )
;; (var entities ((create Entity-system) 10000))

;; (def-interface Tile (x y (data [])))

;; (def-interface Tile-map (lim context)

;;   (extend Pooled-system)
;;   (interface Tile)

;;   (init (.call Pooled-system.init this limit this.interface))

;;   (def spawn (x y)))

;; (def-interface Lighting ())
;; (def-interface Sun ())


;; ;; (def-entity Tile ())
;; ;; (def-entity Road ())
;; ;; (def-entity Building ())

;; ;; (def-interface Agent ())
;; ;; (def-interface Agent.Objective ())



(def-interface Vertex (layer)

  (extend Renderable)

  (structure (new Andy.Gl.Type.Composite
                  (lit (point Andy.Type.Vector3)
                       (color Andy.Color.RGBA)
                       (size Andy.Type.float)))))

(var rendering (.load Rendering
                      (lit (size (window.size))
                           (limit 100)
                           (blend true))))

(var wrap Document-node.wrap)

(var stage
     (dom
      (.div .id 'stage )))

(var container
     (dom
      (.div .id "container"
            stage
            rendering.context.canvas)))

(with-dom Document-root
  (.div .id 'frame container))

(include "./systems/test.sibilant")

(print "DONE LOADING")
